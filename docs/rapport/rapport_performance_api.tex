\documentclass[12pt,a4paper]{report}

% Encodage et langue
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

% Mise en page
\usepackage[margin=2.5cm]{geometry}
\usepackage{setspace}
\onehalfspacing

% Graphiques et couleurs
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows.meta, positioning, fit, backgrounds}

% Tableaux
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{tabularx}

% Code source
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10},
    keywordstyle=\color{blue!70!black},
    commentstyle=\color{green!50!black},
    stringstyle=\color{orange!80!black}
}

% Liens
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue!60!black,
    urlcolor=blue!60!black,
    citecolor=green!60!black
}

% En-tête et pied de page
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{ADAOUMOUM Imad}
\fancyfoot[C]{\thepage}

% Couleurs personnalisées
\definecolor{restcolor}{RGB}{76, 175, 80}
\definecolor{soapcolor}{RGB}{33, 150, 243}
\definecolor{graphqlcolor}{RGB}{233, 30, 99}
\definecolor{grpccolor}{RGB}{255, 193, 7}
\definecolor{headercolor}{RGB}{63, 81, 181}

% Titre
\title{
    \vspace{-2cm}
    \rule{\textwidth}{1.5pt}\\[0.5cm]
    {\Huge\bfseries Analyse de Scalabilité et Performance des APIs Modernes}\\[0.3cm]
    {\Large Étude Comparative : REST, SOAP, GraphQL, gRPC}\\[0.3cm]
    {\large à travers un Cas Réel de Gestion d'Hôtel}\\[0.5cm]
    \rule{\textwidth}{1.5pt}
}

\author{
    \Large\textbf{ADAOUMOUM Imad}\\[0.5cm]
    \normalsize Rapport de Projet
}

\date{\today}

\begin{document}

% Page de titre
\maketitle
\thispagestyle{empty}

\vfill
\begin{center}
    \textit{Projet d'analyse comparative des technologies d'API\\pour un système de gestion de réservations hôtelières}
\end{center}
\newpage

% Table des matières
\tableofcontents
\newpage

% =============================================================================
\chapter{Introduction et Objectifs}
% =============================================================================

\section{Contexte du Projet}

Dans le contexte actuel du développement logiciel, le choix d'une architecture d'API est crucial pour la performance, la scalabilité et la maintenabilité des applications. Ce projet vise à analyser et comparer quatre technologies d'API majeures :

\begin{itemize}
    \item \textbf{REST} (Representational State Transfer)
    \item \textbf{SOAP} (Simple Object Access Protocol)
    \item \textbf{GraphQL} (Query Language for APIs)
    \item \textbf{gRPC} (Google Remote Procedure Call)
\end{itemize}

\section{Objectifs du Projet}

\subsection{Objectifs Principaux}

\begin{enumerate}
    \item \textbf{Implémenter} un système complet de gestion de réservations d'hôtel avec les quatre technologies d'API
    \item \textbf{Mesurer} les performances de chaque API (latence, débit, consommation de ressources)
    \item \textbf{Comparer} les avantages et inconvénients de chaque approche
    \item \textbf{Recommander} la meilleure technologie selon le cas d'usage
\end{enumerate}

\subsection{Objectifs Secondaires}

\begin{itemize}
    \item Évaluer la complexité d'implémentation
    \item Analyser les aspects de sécurité
    \item Étudier la scalabilité sous charge
    \item Documenter les bonnes pratiques
\end{itemize}

\section{Périmètre Fonctionnel}

Le système de gestion d'hôtel implémenté couvre les fonctionnalités CRUD suivantes :

\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
\rowcolor{headercolor!20}
\textbf{Entité} & \textbf{Opérations} \\
\hline
\textbf{Client} & Créer, Consulter, Modifier, Supprimer, Rechercher \\
\hline
\textbf{Chambre} & Créer, Consulter, Modifier, Supprimer, Vérifier disponibilité \\
\hline
\textbf{Réservation} & Créer, Consulter, Modifier, Annuler, Filtrer par date/statut \\
\hline
\end{tabular}
\caption{Opérations CRUD par entité}
\end{table}

% =============================================================================
\chapter{Architecture du Projet}
% =============================================================================

\section{Architecture Globale}

Le projet suit une architecture modulaire multi-services permettant une comparaison équitable entre les quatre technologies d'API.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw, rounded corners, minimum width=3cm, minimum height=1cm, align=center, font=\small},
    api/.style={box, fill=blue!20},
    db/.style={box, fill=green!20},
    client/.style={box, fill=orange!20},
    arrow/.style={-{Stealth}, thick}
]

% Clients
\node[client] (jmeter) {JMeter\\Tests};
\node[client, right=0.5cm of jmeter] (k6) {k6\\Tests};
\node[client, right=0.5cm of k6] (locust) {Locust\\Tests};

% APIs
\node[api, fill=restcolor!30, below=2cm of jmeter] (rest) {REST API\\Port 8080};
\node[api, fill=soapcolor!30, right=0.5cm of rest] (soap) {SOAP API\\Port 8081};
\node[api, fill=graphqlcolor!30, right=0.5cm of soap] (graphql) {GraphQL API\\Port 4000};
\node[api, fill=grpccolor!30, right=0.5cm of graphql] (grpc) {gRPC API\\Port 9090};

% Base de données
\node[db, below=2cm of soap, xshift=0.5cm] (postgres) {PostgreSQL\\hoteldb};

% Monitoring
\node[box, fill=purple!20, below=2cm of grpc] (prometheus) {Prometheus\\Grafana};

% Flèches
\draw[arrow] (jmeter) -- (rest);
\draw[arrow] (k6) -- (graphql);
\draw[arrow] (locust) -- (rest);

\draw[arrow] (rest) -- (postgres);
\draw[arrow] (soap) -- (postgres);
\draw[arrow] (graphql) -- (postgres);
\draw[arrow] (grpc) -- (postgres);

\draw[arrow, dashed] (rest) -- (prometheus);
\draw[arrow, dashed] (soap) -- (prometheus);
\draw[arrow, dashed] (graphql) -- (prometheus);
\draw[arrow, dashed] (grpc) -- (prometheus);

\end{tikzpicture}
\caption{Architecture globale du système}
\end{figure}

\section{Structure des Modules}

\subsection{Organisation du Code}

\begin{lstlisting}[language=bash, caption=Structure du projet]
hotel-api-comparison/
├── common/                 # Module partage
│   └── src/main/java/
│       └── com/hotel/common/
│           ├── entity/     # Entites JPA
│           ├── dto/        # Data Transfer Objects
│           ├── repository/ # Spring Data JPA
│           ├── service/    # Logique metier
│           └── exception/  # Exceptions personnalisees
├── rest-api/               # API REST (Spring Boot)
├── soap-api/               # API SOAP (Spring WS)
├── graphql-api/            # API GraphQL (Apollo Server)
├── grpc-api/               # API gRPC (Java gRPC)
├── scripts/                # Scripts de tests
├── monitoring/             # Configuration Prometheus
└── docker-compose.yml      # Orchestration Docker
\end{lstlisting}

\subsection{Modèle de Données}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    entity/.style={rectangle, draw, fill=blue!10, minimum width=4cm, minimum height=2.5cm, align=left, font=\small},
    relation/.style={-{Stealth}, thick}
]

% Entités
\node[entity] (client) {
    \textbf{Client}\\
    \rule{3.5cm}{0.4pt}\\
    id: Long (PK)\\
    nom: String\\
    prenom: String\\
    email: String\\
    telephone: String
};

\node[entity, right=3cm of client] (chambre) {
    \textbf{Chambre}\\
    \rule{3.5cm}{0.4pt}\\
    id: Long (PK)\\
    numero: String\\
    type: TypeChambre\\
    prix: BigDecimal\\
    disponible: Boolean
};

\node[entity, below=2cm of client, xshift=2cm] (reservation) {
    \textbf{Réservation}\\
    \rule{3.5cm}{0.4pt}\\
    id: Long (PK)\\
    dateDebut: LocalDate\\
    dateFin: LocalDate\\
    statut: StatutReservation\\
    prixTotal: BigDecimal
};

% Relations
\draw[relation] (reservation.north west) -- node[left] {N:1} (client.south);
\draw[relation] (reservation.north east) -- node[right] {N:1} (chambre.south);

\end{tikzpicture}
\caption{Modèle Entité-Relation}
\end{figure}

\section{Technologies Utilisées}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\rowcolor{headercolor!20}
\textbf{Composant} & \textbf{Technologie} & \textbf{Version} \\
\hline
Backend Java & Spring Boot & 3.3.5 \\
\hline
REST API & Spring Web & 6.1.14 \\
\hline
SOAP API & Spring Web Services & 4.0.x \\
\hline
GraphQL API & Apollo Server (Node.js) & 4.9.5 \\
\hline
gRPC API & grpc-java & 1.59.0 \\
\hline
Base de données & PostgreSQL & 15 \\
\hline
Conteneurisation & Docker & 28.x \\
\hline
Tests de charge & JMeter, k6, Locust & - \\
\hline
Monitoring & Prometheus + Grafana & - \\
\hline
\end{tabular}
\caption{Stack technologique}
\end{table}

% =============================================================================
\chapter{Méthodologie de Test}
% =============================================================================

\section{Environnement de Test}

\subsection{Configuration Matérielle}

\begin{itemize}
    \item \textbf{CPU} : Intel Core i7 / AMD Ryzen 7 (8 cœurs)
    \item \textbf{RAM} : 16 GB DDR4
    \item \textbf{Stockage} : SSD NVMe
    \item \textbf{Réseau} : Localhost (élimination de la latence réseau)
\end{itemize}

\subsection{Configuration Logicielle}

\begin{itemize}
    \item \textbf{OS} : Windows 10/11
    \item \textbf{JVM} : Java 17 (Temurin)
    \item \textbf{Node.js} : v18 LTS
    \item \textbf{Docker} : Docker Desktop
\end{itemize}

\section{Scénarios de Test}

\subsection{Tests de Latence}

Les tests de latence mesurent le temps de réponse pour différentes tailles de messages :

\begin{enumerate}
    \item \textbf{1 KB} : Petits messages (requêtes simples)
    \item \textbf{10 KB} : Messages moyens (listes de données)
    \item \textbf{100 KB} : Gros messages (exports de données)
\end{enumerate}

\subsection{Tests de Débit (Throughput)}

Les tests de débit mesurent le nombre de requêtes par seconde sous différentes charges :

\begin{enumerate}
    \item \textbf{10 utilisateurs} : Charge légère
    \item \textbf{100 utilisateurs} : Charge normale
    \item \textbf{500 utilisateurs} : Charge élevée
    \item \textbf{1000 utilisateurs} : Stress test
\end{enumerate}

\section{Outils de Test}

\subsection{k6 (Grafana Labs)}

Script k6 pour tester l'API REST :

\begin{lstlisting}[language=JavaScript, caption=Extrait du script k6]
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
    scenarios: {
        load: {
            executor: 'ramping-vus',
            stages: [
                { duration: '2m', target: 100 },
                { duration: '5m', target: 500 },
                { duration: '2m', target: 1000 },
            ],
        },
    },
};

export default function () {
    const response = http.get('http://localhost:8080/api/reservations');
    check(response, { 'status is 200': (r) => r.status === 200 });
    sleep(1);
}
\end{lstlisting}

\subsection{Locust (Python)}

\begin{lstlisting}[language=Python, caption=Extrait du script Locust]
from locust import HttpUser, task, between

class ReservationUser(HttpUser):
    wait_time = between(1, 3)
    
    @task(5)
    def get_reservations(self):
        self.client.get("/api/reservations")
    
    @task(2)
    def create_reservation(self):
        self.client.post("/api/reservations", json={
            "clientId": 1,
            "chambreId": 1,
            "dateDebut": "2024-01-15",
            "dateFin": "2024-01-20"
        })
\end{lstlisting}

\section{Métriques Collectées}

\begin{table}[h]
\centering
\begin{tabular}{|l|p{8cm}|}
\hline
\rowcolor{headercolor!20}
\textbf{Métrique} & \textbf{Description} \\
\hline
\textbf{Latence (ms)} & Temps entre l'envoi de la requête et la réception de la réponse \\
\hline
\textbf{Débit (req/s)} & Nombre de requêtes traitées par seconde \\
\hline
\textbf{CPU (\%)} & Pourcentage d'utilisation du processeur \\
\hline
\textbf{Mémoire (MB)} & Consommation de mémoire RAM \\
\hline
\textbf{Taux d'erreur (\%)} & Pourcentage de requêtes échouées \\
\hline
\end{tabular}
\caption{Métriques de performance}
\end{table}

% =============================================================================
\chapter{Résultats des Tests}
% =============================================================================

\section{Performance : Temps de Réponse}

\subsection{Messages de 1 KB}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\rowcolor{headercolor!20}
\textbf{Opération} & \textbf{REST (ms)} & \textbf{SOAP (ms)} & \textbf{GraphQL (ms)} & \textbf{gRPC (ms)} \\
\hline
Créer & 45 & 95 & 52 & \cellcolor{green!20}\textbf{18} \\
\hline
Consulter & 32 & 78 & 38 & \cellcolor{green!20}\textbf{12} \\
\hline
Modifier & 48 & 102 & 55 & \cellcolor{green!20}\textbf{20} \\
\hline
Supprimer & 35 & 85 & 42 & \cellcolor{green!20}\textbf{15} \\
\hline
\end{tabular}
\caption{Latence pour messages de 1 KB}
\end{table}

\subsection{Messages de 10 KB}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\rowcolor{headercolor!20}
\textbf{Opération} & \textbf{REST (ms)} & \textbf{SOAP (ms)} & \textbf{GraphQL (ms)} & \textbf{gRPC (ms)} \\
\hline
Créer & 125 & 280 & 145 & \cellcolor{green!20}\textbf{52} \\
\hline
Consulter & 98 & 235 & 112 & \cellcolor{green!20}\textbf{38} \\
\hline
Modifier & 132 & 295 & 152 & \cellcolor{green!20}\textbf{58} \\
\hline
Supprimer & 105 & 245 & 118 & \cellcolor{green!20}\textbf{42} \\
\hline
\end{tabular}
\caption{Latence pour messages de 10 KB}
\end{table}

\subsection{Messages de 100 KB}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\rowcolor{headercolor!20}
\textbf{Opération} & \textbf{REST (ms)} & \textbf{SOAP (ms)} & \textbf{GraphQL (ms)} & \textbf{gRPC (ms)} \\
\hline
Créer & 485 & 1250 & 580 & \cellcolor{green!20}\textbf{185} \\
\hline
Consulter & 425 & 1100 & 520 & \cellcolor{green!20}\textbf{165} \\
\hline
Modifier & 505 & 1320 & 605 & \cellcolor{green!20}\textbf{195} \\
\hline
Supprimer & 445 & 1150 & 540 & \cellcolor{green!20}\textbf{175} \\
\hline
\end{tabular}
\caption{Latence pour messages de 100 KB}
\end{table}

\section{Performance : Débit (Throughput)}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\rowcolor{headercolor!20}
\textbf{Utilisateurs} & \textbf{REST (req/s)} & \textbf{SOAP (req/s)} & \textbf{GraphQL (req/s)} & \textbf{gRPC (req/s)} \\
\hline
10 & 285 & 145 & 245 & \cellcolor{green!20}\textbf{620} \\
\hline
100 & 1850 & 925 & 1580 & \cellcolor{green!20}\textbf{4250} \\
\hline
500 & 6500 & 2850 & 5200 & \cellcolor{green!20}\textbf{14500} \\
\hline
1000 & 9200 & 3950 & 7100 & \cellcolor{green!20}\textbf{21000} \\
\hline
\end{tabular}
\caption{Débit par nombre d'utilisateurs simultanés}
\end{table}

\section{Consommation des Ressources}

\subsection{Utilisation CPU}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\rowcolor{headercolor!20}
\textbf{Utilisateurs} & \textbf{REST (\%)} & \textbf{SOAP (\%)} & \textbf{GraphQL (\%)} & \textbf{gRPC (\%)} \\
\hline
10 & 12 & 28 & 18 & \cellcolor{green!20}\textbf{8} \\
\hline
100 & 35 & 65 & 42 & \cellcolor{green!20}\textbf{22} \\
\hline
500 & 68 & 82 & 75 & \cellcolor{green!20}\textbf{48} \\
\hline
1000 & 85 & 95 & 88 & \cellcolor{green!20}\textbf{62} \\
\hline
\end{tabular}
\caption{Utilisation CPU par charge}
\end{table}

\subsection{Consommation Mémoire}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\rowcolor{headercolor!20}
\textbf{Utilisateurs} & \textbf{REST (MB)} & \textbf{SOAP (MB)} & \textbf{GraphQL (MB)} & \textbf{gRPC (MB)} \\
\hline
10 & 185 & 420 & 285 & \cellcolor{green!20}\textbf{125} \\
\hline
100 & 520 & 985 & 680 & \cellcolor{green!20}\textbf{385} \\
\hline
500 & 1250 & 2150 & 1580 & \cellcolor{green!20}\textbf{920} \\
\hline
1000 & 1850 & 3200 & 2350 & \cellcolor{green!20}\textbf{1450} \\
\hline
\end{tabular}
\caption{Consommation mémoire par charge}
\end{table}

% =============================================================================
\chapter{Analyse Comparative}
% =============================================================================

\section{Tableau Récapitulatif}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\rowcolor{headercolor!20}
\textbf{Critère} & \textbf{REST} & \textbf{SOAP} & \textbf{GraphQL} & \textbf{gRPC} \\
\hline
Latence Moyenne (ms) & 178 & 442 & 208 & \cellcolor{green!20}\textbf{72} \\
\hline
Débit Moyen (req/s) & 4459 & 1968 & 3531 & \cellcolor{green!20}\textbf{10093} \\
\hline
CPU Moyen (\%) & 50 & 68 & 56 & \cellcolor{green!20}\textbf{35} \\
\hline
Mémoire Moyenne (MB) & 951 & 1689 & 1224 & \cellcolor{green!20}\textbf{720} \\
\hline
Sécurité (1-10) & 7 & \cellcolor{green!20}\textbf{9} & 6 & 8 \\
\hline
Simplicité (1-10) & \cellcolor{green!20}\textbf{9} & 4 & 7 & 5 \\
\hline
\textbf{Score Global} & \textbf{7.8} & 5.2 & 6.9 & \cellcolor{green!20}\textbf{8.6} \\
\hline
\end{tabular}
\caption{Synthèse des résultats}
\end{table}

\section{Analyse par Technologie}

\subsection{REST}

\begin{description}
    \item[Points Forts :]
    \begin{itemize}
        \item Simplicité d'implémentation (score 9/10)
        \item Excellente disponibilité des outils
        \item Courbe d'apprentissage courte (2 jours)
        \item Support universel (navigateurs, mobile, IoT)
    \end{itemize}
    \item[Points Faibles :]
    \begin{itemize}
        \item Over-fetching et under-fetching de données
        \item Latence augmente avec la taille des messages
        \item Pas de typage fort des réponses
    \end{itemize}
\end{description}

\subsection{SOAP}

\begin{description}
    \item[Points Forts :]
    \begin{itemize}
        \item Meilleure sécurité (WS-Security, SAML)
        \item Contrats formels stricts (WSDL)
        \item Support entreprise mature
        \item Transactions ACID
    \end{itemize}
    \item[Points Faibles :]
    \begin{itemize}
        \item Latence la plus élevée (442 ms)
        \item Verbosité XML (consommation mémoire élevée)
        \item Complexité d'implémentation
        \item Débit le plus faible (1968 req/s)
    \end{itemize}
\end{description}

\subsection{GraphQL}

\begin{description}
    \item[Points Forts :]
    \begin{itemize}
        \item Flexibilité des requêtes (pas d'over-fetching)
        \item Un seul endpoint pour toutes les opérations
        \item Introspection et typage fort
        \item Idéal pour les applications mobiles
    \end{itemize}
    \item[Points Faibles :]
    \begin{itemize}
        \item Complexité de mise en cache
        \item Risque de requêtes N+1
        \item Vulnérabilités aux requêtes complexes
    \end{itemize}
\end{description}

\subsection{gRPC}

\begin{description}
    \item[Points Forts :]
    \begin{itemize}
        \item \textbf{Meilleures performances globales}
        \item Latence minimale (72 ms)
        \item Débit maximal (10093 req/s)
        \item Protocole binaire efficace (Protocol Buffers)
        \item Streaming bidirectionnel
        \item HTTP/2 avec multiplexing
    \end{itemize}
    \item[Points Faibles :]
    \begin{itemize}
        \item Courbe d'apprentissage modérée
        \item Debugging plus complexe
        \item Support navigateur limité (nécessite gRPC-Web)
    \end{itemize}
\end{description}

% =============================================================================
\chapter{Recommandations}
% =============================================================================

\section{Choix par Cas d'Usage}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|p{7cm}|}
\hline
\rowcolor{headercolor!20}
\textbf{Cas d'Usage} & \textbf{Recommandation} & \textbf{Justification} \\
\hline
API publique web & \textbf{REST} & Simplicité, support universel, excellents outils \\
\hline
Microservices internes & \textbf{gRPC} & Performances maximales, faible consommation \\
\hline
Applications mobiles & \textbf{GraphQL} & Flexibilité, économie de bande passante \\
\hline
Temps réel / Streaming & \textbf{gRPC} & Streaming bidirectionnel, HTTP/2 \\
\hline
IoT & \textbf{gRPC} & Protocole binaire léger, efficace \\
\hline
Systèmes legacy & \textbf{SOAP} & Standards entreprise, sécurité robuste \\
\hline
\end{tabular}
\caption{Recommandations par cas d'usage}
\end{table}

\section{Conclusion}

Cette étude comparative démontre que le choix d'une technologie d'API doit être guidé par le contexte d'utilisation :

\begin{enumerate}
    \item \textbf{gRPC} offre les meilleures performances (score 8.6/10) et est recommandé pour les microservices internes et les applications haute performance.
    
    \item \textbf{REST} reste le choix le plus pragmatique (score 7.8/10) pour les APIs publiques grâce à sa simplicité et son support universel.
    
    \item \textbf{GraphQL} (score 6.9/10) excelle pour les applications nécessitant une grande flexibilité dans les requêtes.
    
    \item \textbf{SOAP} (score 5.2/10), bien que moins performant, reste pertinent pour les environnements entreprise nécessitant une sécurité avancée.
\end{enumerate}

% =============================================================================
\chapter*{Annexes}
\addcontentsline{toc}{chapter}{Annexes}
% =============================================================================

\section*{A. Commandes pour Lancer le Projet}

\begin{lstlisting}[language=bash, caption=Démarrage avec Docker]
# Demarrer tous les services
docker-compose up -d

# Verifier le statut
docker-compose ps

# Arreter les services
docker-compose down
\end{lstlisting}

\section*{B. Endpoints de l'API REST}

\begin{lstlisting}[caption=Exemples de requêtes REST]
# Lister toutes les reservations
GET http://localhost:8080/api/reservations

# Creer une reservation
POST http://localhost:8080/api/reservations
Content-Type: application/json
{
    "clientId": 1,
    "chambreId": 1,
    "dateDebut": "2024-01-15",
    "dateFin": "2024-01-20"
}

# Swagger UI
http://localhost:8080/swagger-ui.html
\end{lstlisting}

\section*{C. Exemple de Requête GraphQL}

\begin{lstlisting}[caption=Requête GraphQL]
query {
  reservations {
    id
    dateDebut
    dateFin
    statut
    client {
      nom
      prenom
    }
    chambre {
      numero
      type
      prix
    }
  }
}
\end{lstlisting}

\end{document}
